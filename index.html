<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ztt0tian.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="可能不够详细，但会尽量实用">
<meta property="og:type" content="website">
<meta property="og:title" content="不知名TT">
<meta property="og:url" content="https://ztt0tian.github.io/index.html">
<meta property="og:site_name" content="不知名TT">
<meta property="og:description" content="可能不够详细，但会尽量实用">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhaotian">
<meta property="article:tag" content="java,mysql,markdown,redis,spring,rabbitmq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ztt0tian.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不知名TT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不知名TT</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个coder的自我修养</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">66</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-java">

    <a href="/categories/java/" rel="section"><i class="fa fa-fw fa-coffee"></i>JAVA</a>

  </li>
        <li class="menu-item menu-item-db">

    <a href="/categories/database/" rel="section"><i class="fa fa-fw fa-database"></i>DB</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/categories/tools/" rel="section"><i class="fa fa-fw fa-anchor"></i>Tools</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/22/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/ConcurrentHashMap/" class="post-title-link" itemprop="url">concurrentHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-22 23:20:31" itemprop="dateCreated datePublished" datetime="2022-03-22T23:20:31+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 23:03:10" itemprop="dateModified" datetime="2022-03-23T23:03:10+08:00">2022-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jdk%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">jdk源码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h1><p>检索操作不会受并发导致阻塞，对于一些聚合操作(putAll/clear)，并发访问可能只会反应出一部分的更新效果。</p>
<p>迭代器中的修改不会发生<code>ConcurrentModificationException</code>，但是某个特定时刻只会允许一个线程去修改。一些聚合状态的方法<code>size</code>、<code>isEmpty</code>、<code>containsValue</code>只有当不存在受其它线程的并发更新影响时才有用。其结果只能反映瞬时状态，但是对于监控或评估足够了，但不适合程序控制。在构造对象实例时提供一个预估的size是个好的选择，避免过多的resize和rehash（相对比较耗时的操作）</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/21/DevOps/k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/DevOps/k8s/" class="post-title-link" itemprop="url">k8s</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 21:53:02" itemprop="dateCreated datePublished" datetime="2022-03-21T21:53:02+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 11:23:16" itemprop="dateModified" datetime="2022-03-27T11:23:16+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kubernetes(k8s)就是按照用户的期望的样子来运行部署应用程序</p>
<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cloud_computing/">云计算</a></p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="HELM"><a href="#HELM" class="headerlink" title="HELM"></a>HELM</h1><p>k8s搭建</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/spll/p/10033316.html">https://www.cnblogs.com/spll/p/10033316.html</a></p>
<p>问题解决：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mwtsai/p/15102016.html">https://www.cnblogs.com/mwtsai/p/15102016.html</a></p>
<p>failed to retrieve network config: client: etcd cluster is unavailable or misconfigured; error #0: dial tcp 172.17.0.4:2379: getsockopt: no route to host  关掉防火墙即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/17/CodeTop/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/17/CodeTop/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-17 21:20:24 / 修改时间：21:20:55" itemprop="dateCreated datePublished" datetime="2022-03-17T21:20:24+08:00">2022-03-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归之后得到一个当时翻转的那个节点的引用</span></span><br><span class="line">    ListNode newNode = reverseList(head.next);</span><br><span class="line">    <span class="comment">// 将第n-1次递归的入参节点尾插到第n次递归的尾结点之后</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里每次返回的都是最后的那个节点的引用（每次递归返回都会增加其长度）</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/17/CodeTop/LRU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/17/CodeTop/LRU/" class="post-title-link" itemprop="url">CodeTop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-17 19:52:19 / 修改时间：19:56:45" itemprop="dateCreated datePublished" datetime="2022-03-17T19:52:19+08:00">2022-03-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">算法题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>map(缓存容器)+双链表(维护缓存顺序)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Map&lt;Integer, Node&gt; cacheMap;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">            Node node = cacheMap.get(key);</span><br><span class="line">            afterAccessNode(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问某个节点后将其放置在双链表的最后（表示缓存最新）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterAccessNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node last = tail;</span><br><span class="line">        <span class="comment">// 访问非尾结点 才需要调整顺序</span></span><br><span class="line">        <span class="keyword">if</span> (node != last) &#123;</span><br><span class="line">            Node p = node, thePre = p.pre, theNext = p.next;</span><br><span class="line">            <span class="comment">// 当前节点最后是要成为尾结点的 故后置节点必须置空</span></span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 前节点的处理</span></span><br><span class="line">            <span class="keyword">if</span> (thePre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = theNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                thePre.next = theNext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后节点的处理(其实不可能为空)</span></span><br><span class="line">            theNext.pre = thePre;</span><br><span class="line">            <span class="comment">// last节点（原尾结点）处理</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = p;</span><br><span class="line">                p.pre = last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾结点指向p</span></span><br><span class="line">            tail = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">            Node node = cacheMap.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            <span class="comment">// put 已有key 更新其值 调用一次访问调整</span></span><br><span class="line">            afterAccessNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            addNodeLast(node);</span><br><span class="line">            <span class="comment">// 判断是否超过缓存阈值</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                removeHeadNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除头结点（最旧的缓存）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeHeadNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h = head, hnext = head.next;</span><br><span class="line">        cacheMap.remove(h.key);</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 头结点冲双链表中移除</span></span><br><span class="line">        h.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 其后置节点（未来的头结点）的前置节点置空</span></span><br><span class="line">        <span class="keyword">if</span> (hnext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hnext.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = hnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点（尾插法）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNodeLast</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        cacheMap.put(node.key, node);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node last = tail;</span><br><span class="line">            last.next = node;</span><br><span class="line">            node.pre = last;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/13/docker/%E8%BD%AF%E4%BB%B6%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/13/docker/%E8%BD%AF%E4%BB%B6%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8/" class="post-title-link" itemprop="url">docker软件镜像</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-13 17:11:22" itemprop="dateCreated datePublished" datetime="2022-03-13T17:11:22+08:00">2022-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 16:32:02" itemprop="dateModified" datetime="2022-03-27T16:32:02+08:00">2022-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="registry（本地仓库）"><a href="#registry（本地仓库）" class="headerlink" title="registry（本地仓库）"></a>registry（本地仓库）</h1><p>搭建本地私有docker仓库 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaojiankai/p/7813969.html">参考</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search registry</span><br><span class="line">docker pull registry</span><br><span class="line">docker run -d -p 5000:5000 --restart=always --name registry-container --hostname registry registry</span><br></pre></td></tr></table></figure>

<p><strong>生产环境的 registry 必须受 TLS 保护，并且应该使用访问控制机制</strong></p>
<h1 id="portainer（docker-UI）"><a href="#portainer（docker-UI）" class="headerlink" title="portainer（docker UI）"></a>portainer（docker UI）</h1><p>docker管理UI（可视化工具） <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36190858/article/details/86476393">参考</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search portainer</span><br><span class="line">docker pull portainer/portainer</span><br><span class="line">docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data --name prtainer-test portainer/portainer</span><br></pre></td></tr></table></figure>

<p>参数说明：<br>-d：容器在后台运行；<br>-p 9000:9000 ：宿主机9000端口映射容器中的9000端口<br>–restart 标志会检查容器的退出代码，并据此来决定是否要重启容器，默认是不会重启。</p>
<p>–restart=always：自动重启该容器<br>-v /var/run/docker.sock:/var/run/docker.sock ：把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中<br>-v portainer_data:/data ：把宿主机portainer_data数据卷挂载到容器/data目录<br>–name prtainer-test ： 给容器起名为portainer-test</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:9000/">http://localhost:9000/</a></p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34775355/article/details/108305396">https://blog.csdn.net/qq_34775355/article/details/108305396</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.7-management</span><br><span class="line">docker run -d --name rabbitmq3.7.7 -p 5672:5672 -p 15672:15672 -v D:/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin 镜像ID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672/</a></p>
<h1 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search activemq</span><br><span class="line">docker pull webcenter/activemq</span><br><span class="line">docker run --name=activemq -itd -p 8161:8161 -p 61616:61616 -e ACTIVEMQ_ADMIN_LOGIN=admin -e ACTIVEMQ_ADMIN_PASSWORD=Abc12345 --restart=always -v D:/mountdir/activeMq:/data/activemq -v D:/mountdir/activeMq/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/activemq webcenter/activemq:latest</span><br></pre></td></tr></table></figure>

<p>访问:<a target="_blank" rel="noopener" href="http://localhost:8161/">http://localhost:8161/</a></p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yufeng218/p/9452621.html">https://www.cnblogs.com/yufeng218/p/9452621.html</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br><span class="line">docker pull mysql</span><br><span class="line">docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure>

<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SmilingEye/p/11835040.html">参考</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search postgres</span><br><span class="line">docker pull postgres</span><br><span class="line">docker run -itd --name postgres-test -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e TZ=PRC postgres</span><br></pre></td></tr></table></figure>

<p>用户名/密码：postgres/123456</p>
<p>-e POSTGRES_PASSWORD 密码（默认用户名postgres）</p>
<p>-e TZ=PRC时区，中国</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/az4215/p/11865313.html">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br><span class="line">docker pull redis</span><br><span class="line">docker run -it -d --name myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<p>最简单的启动方式</p>
<p>主从+哨兵：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72ee9568c8ea">https://www.jianshu.com/p/72ee9568c8ea</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/08/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">钩子方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-08 22:17:18 / 修改时间：22:56:13" itemprop="dateCreated datePublished" datetime="2022-03-08T22:17:18+08:00">2022-03-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/180164.htm">https://www.jb51.net/article/180164.htm</a></p>
<h1 id="抽象模板类"><a href="#抽象模板类" class="headerlink" title="抽象模板类"></a>抽象模板类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类 定义一些模板子方法 （模板）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体方法 抽象类中声明并实现，继承此抽象类一般不需实现此方法（当然也可以选择覆写）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concreteMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法 抽象类中仅声明，实现类继承时需要进行具体实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钩子方法 在抽象类中是一般是一个空实现异或跟具体方法一样有个默认实现 实现类继承时可选择进行方法扩展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法 集成了一系列的方法调用（完成一个完整业务）一般模板方法不会在实现类中覆写 其调用逻辑已成型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        concreteMethod();</span><br><span class="line">        abstractMethod();</span><br><span class="line">        hookMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><h2 id="ClassA"><a href="#ClassA" class="headerlink" title="ClassA"></a>ClassA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法A实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concreteMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.concreteMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;在原具体方法基础上增加额外业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassA的钩子方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassB"><a href="#ClassB" class="headerlink" title="ClassB"></a>ClassB</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法B实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassB的钩子方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass abstractClassA = <span class="keyword">new</span> ClassA();</span><br><span class="line">        AbstractClass abstractClassB = <span class="keyword">new</span> ClassB();</span><br><span class="line">        abstractClassA.templateMethod();</span><br><span class="line">        abstractClassB.templateMethod();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">具体方法</span><br><span class="line">在原具体方法基础上增加额外业务</span><br><span class="line">抽象方法A实现</span><br><span class="line">ClassA的钩子方法</span><br><span class="line">具体方法</span><br><span class="line">抽象方法B实现</span><br><span class="line">ClassB的钩子方法</span><br></pre></td></tr></table></figure>

<h1 id="源码体现"><a href="#源码体现" class="headerlink" title="源码体现"></a>源码体现</h1><p>jdk中HashMap中定义了许多空方法（其实就是钩子方法），并在get、put等方法上进行调用，而LinkedHash继承了HashMap，并重写了那些空方法，并且LinkedHashMap不会再去重写get、put等方法，而是直接使用从HashMap中继承而来的方法，与原实现的区别就在于这些空方法的实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/07/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/LinkedHashMap/" class="post-title-link" itemprop="url">LinkedHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 21:25:21" itemprop="dateCreated datePublished" datetime="2022-03-07T21:25:21+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 22:45:13" itemprop="dateModified" datetime="2022-03-09T22:45:13+08:00">2022-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h1><p>在HashMap的基础上维护了一个双向链表，其定义了迭代顺序，通常是插入顺序，相同的key重新插入覆写不会影响原有顺序</p>
<p><code>Map copy = new LinkedHashMap(m)</code> 可保证与原有map的元素顺序一致</p>
<p>有个构造方法<code>LinkedHashMap(int,float,boolean)</code>很适合用来构建一个LRU缓存[最远到最近被访问的访问顺序]</p>
<p><code>put</code><br><code>putIfAbsent</code><br><code>get</code><br><code>getOrDefault</code><br><code>compute</code><br><code>computeIfAbsent</code><br><code>computeIfPresent</code><br><code>merge</code><br><code>replace</code> (仅发生值改变才会认为最近访问)<br><code>putAll</code> (为每个映射认为最近访问)<br>当添加新映射时，可以通过覆写<code>removeEldestEntry</code>方法来选择是否删除最老的键值对，默认实现是不删除（在利用该类实现LRU时可通过该方法来限制最大缓存数量）</p>
<p>性能略逊于<code>HashMap</code>因为要维护双向链表</p>
<p>LinkedHashMap和HashMap一样都是非同步的，同步化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap(...));</span><br></pre></td></tr></table></figure>

<p>在access-order（访问顺序）的LinkedHashMap中，仅仅是用get方法查询map就是一种结构上的修改。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双链表 头结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">// 双链表 尾结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">// 访问顺序flag  true-基于访问顺序 false-基于插入顺序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>在HashMap的Node节点基础上增加前后指针的声明 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="内部工具方法"><a href="#内部工具方法" class="headerlink" title="内部工具方法"></a>内部工具方法</h1><h2 id="linkNodeLast"><a href="#linkNodeLast" class="headerlink" title="linkNodeLast"></a>linkNodeLast</h2><p>将节点连接在链表末端，尾插法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">// 首次链接</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前前置节点为原尾结点</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            <span class="comment">// 原尾结点置位当前结点</span></span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="transferLinks"><a href="#transferLinks" class="headerlink" title="transferLinks"></a>transferLinks</h2><p>在替换节点的时候，需要对LinkedHashMap 中的双向链表进维护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = dst;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = dst;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = dst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="覆写钩子方法"><a href="#覆写钩子方法" class="headerlink" title="覆写钩子方法"></a>覆写钩子方法</h1><h2 id="reinitialize"><a href="#reinitialize" class="headerlink" title="reinitialize"></a>reinitialize</h2><p>重置map，额外需要置空双链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.reinitialize();</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="newNode"><a href="#newNode" class="headerlink" title="newNode"></a>newNode</h2><p>覆写新建节点方法，将节点维护的双向链表的尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="replacementNode"><a href="#replacementNode" class="headerlink" title="replacementNode"></a>replacementNode</h2><p>// 树型节点退化普通链表节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        <span class="comment">// 增加对双向链表的维护</span></span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="newTreeNode"><a href="#newTreeNode" class="headerlink" title="newTreeNode"></a>newTreeNode</h2><p>新建树型节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="replacementTreeNode"><a href="#replacementTreeNode" class="headerlink" title="replacementTreeNode"></a>replacementTreeNode</h2><p>将原节点转成树型节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">        transferLinks(q, t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h2><p>移除节点时维护双向链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h2><p>evict这个变量当在map构造器传入指定map初始化的时候是false，其他情况为true，也即其他构造器创建map之后再调用put方法，该参数则为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="comment">// 选择性移除</span></span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h2><p>如果按访问顺序排列，则将访问的节点放置来双向链表最后（最新的缓存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="comment">// 访问的节点不是最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            <span class="comment">// b前节点 a后节点</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            <span class="comment">// 当前节点后节点置空</span></span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 前节点若为空，则头结点就是后节点；否则前节点的后置节点为后节点</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="comment">// 设置后节点的前节点,若后节点为空 则双向链表尾部节点就是当前节点的前节点</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="comment">// 最后将当前节点连在链表尾部</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾结点置为当前节点</span></span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>其它构造函数与HashMap的类似</p>
<p>这里提供了一个设置accessOrder的入口，可用该构造函数实现LRU，记得重写<code>removeEldestEntry</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/06/%E5%B8%B8%E8%AF%86/%E8%82%A1%E7%A5%A8%E6%8C%87%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/%E5%B8%B8%E8%AF%86/%E8%82%A1%E7%A5%A8%E6%8C%87%E6%A0%87/" class="post-title-link" itemprop="url">股票指标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-06 15:46:43 / 修改时间：23:34:20" itemprop="dateCreated datePublished" datetime="2022-03-06T15:46:43+08:00">2022-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MA"><a href="#MA" class="headerlink" title="MA"></a>MA</h1><p>简单移动平均线(Moving Average)，MA(N)表示N个单位周期的平均值，如MA5、MA10、MA20。短线ma指标结合长线ma指标判断走势</p>
<h1 id="EMA"><a href="#EMA" class="headerlink" title="EMA"></a>EMA</h1><p>时间权值+MA</p>
<p>指数移动平均值(Exponential Moving Average),以指数式递减加权的移动平均，是一种均线的衍生指标，但要比MA指标更加灵敏。里面加进了时间作平滑因子的权数，对时间距当前最近的赋给相对大的权重，而较远的权重较小，也就是说最近的股价对当前的影响最大</p>
<h1 id="BOLL"><a href="#BOLL" class="headerlink" title="BOLL"></a>BOLL</h1><p>存在滞后性</p>
<p>布林指标參考：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1724852951910697226">https://baijiahao.baidu.com/s?id=1724852951910697226</a></p>
<p>价格在中轨和上轨（压力位）之间，表明价格强势，趋向多头，适合做多，越靠近上轨，越需要注意超买回调。</p>
<p>价格在中轨和下轨（支撑位）之间，表明价格弱势，趋向空头，适合做空，越靠近下轨，越需要注意超卖回调。</p>
<p>遇见收口多观察（横盘），遇见开口定方向（涨or跌）</p>
<p>开口</p>
<ul>
<li>三条布林线同时向上，并逐渐走宽，多头行情</li>
<li>上轨快速向上，下轨快速向下，中轨上行也是一种股价转强的征兆</li>
<li>向下开口，上轨向下或者快速向上，下轨向下运行，中轨掉头向下，是一种非常明显的股价走弱状态，空头行情</li>
</ul>
<p>收口：</p>
<p>逐渐横盘，此轮行情稳定下来，关注下次开口方向</p>
<h1 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h1><p>价格移动平均线，参考：<a target="_blank" rel="noopener" href="https://www.aniu.tv/gp_article_515059.shtml">https://www.aniu.tv/gp_article_515059.shtml</a></p>
<p>每次价格触及SAR指标则进行SAR涨跌趋向的反转</p>
<h1 id="vloume"><a href="#vloume" class="headerlink" title="vloume"></a>vloume</h1><p>成交量指标 参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6be44c4143b9/">https://www.jianshu.com/p/6be44c4143b9/</a></p>
<p>持续上涨+成交量突然急增+股价上涨乏力   后续空头趋势</p>
<p>持续下跌+成交量突然急增+股价下跌幅度偏小 后续多头趋势</p>
<p>股票长期成交量减少,就是股票走势开始低迷的信号,</p>
<h1 id="MACD-12-26-9"><a href="#MACD-12-26-9" class="headerlink" title="MACD(12,26,9)"></a>MACD(12,26,9)</h1><p>趋势性指标</p>
<p>參考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29954111">https://www.zhihu.com/question/29954111</a></p>
<p>三大要素：DIF、DEA和红柱绿柱</p>
<blockquote>
<p>DIF</p>
</blockquote>
<p>DIF=12日EMA-26日EMA 其绝对值大小，代表着长短期均线距离（开口）的大小</p>
<p>在趋势行情中，金叉与死叉是有效的买卖信号，但在震荡行情中，金叉与死叉基本上都是假信号。</p>
<p>上涨趋势中出现顶背离[<strong>股价在上涨，但DIF却在不断下跌，即随着股价上涨，两条均线之间的距离未能创出新高</strong>]，意味着短期可能出现下跌。</p>
<p>下跌趋势中出现低背离[<strong>股价在下跌，但DIF却在不断下跌，即随着股价下跌，两条均线之间的距离未能创出新高</strong>]，意味着短期可能出现上漲。</p>
<blockquote>
<p>DEA</p>
</blockquote>
<p>DIF值的移动平均线，一般是软件默认是9日平均线</p>
<ul>
<li><p>当DIF在零轴之上时</p>
<p>DIF与DEA金叉，意味着DIF正在变大，即股价的长短期均线距离在变大，股价上涨势头越来越猛。</p>
<p>DIF与DEA死叉，意味着DIF正在变小，即股价的长短期均线的距离正在变小，股价目前上涨势头正在变弱。</p>
</li>
<li><p>当DIF在零轴之下时</p>
</li>
</ul>
<p>​      DIF与DEA金叉，意味着DIF正在变小，即股价的长短期均线的距离正在变小，股价目前下跌势头正在变弱。</p>
<p>​      DIF与DEA死叉，此时DIF是负值，也就是说DIF的绝对值在变大，即股价的长短期均线距离在变大，股价下跌势头越来越强。</p>
<blockquote>
<p>红柱绿柱</p>
</blockquote>
<p>红涨 绿跌</p>
<p>（DIF-DEA）*2即是柱子的数值，红柱为正值，绿柱为负值</p>
<p>红绿柱越长，代表DIF与DEA的距离越大，也就是上涨或下跌的力度越大。</p>
<p>当红柱变为绿柱时，对应着DIF与DEA的死叉；当绿柱变为红柱时，对应着DIF与DEA的金叉</p>
<h1 id="KDJ"><a href="#KDJ" class="headerlink" title="KDJ"></a>KDJ</h1><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4baead60c9c2">https://www.jianshu.com/p/4baead60c9c2</a></p>
<p><a target="_blank" rel="noopener" href="http://www.360doc.com/content/17/0407/14/2522716_643616018.shtml">http://www.360doc.com/content/17/0407/14/2522716_643616018.shtml</a></p>
<p>超买超卖型指标 （适合短中期交易）</p>
<p>KDJ(9,3,3) </p>
<p>三条曲线 K(白) D(黄) J(紫)</p>
<p>J线数值变化最快，又被称之为超快线，或称确认线。主要用来确认K线与D线所发出的买卖信号，作为辅助观察线。k线数值变化速度在三条曲线中属于中等，但与D线比起来速度稍快于D线，因此，K线又被称之为快线。D线在三条曲线中变化速度最慢，所以D线又被称之为慢线。</p>
<blockquote>
<p>KDJ超买信号</p>
</blockquote>
<p>K&gt;90 D&gt;80 J&gt;100(持续3天) kdj超买 短期回调概率大</p>
<blockquote>
<p>KDJ超卖信号</p>
</blockquote>
<p>K&lt;10 D&lt;20 J&lt;0(持续3天) kdj超卖 下跌能力减弱 反弹概率大</p>
<blockquote>
<p>KDJ买卖原则</p>
</blockquote>
<p>就取值而言,一般来说,KD超过80就应该考虑卖出,低于20就应该考虑买入</p>
<blockquote>
<p>KDJ金叉</p>
</blockquote>
<p>​        当K线向上突破D线时，快线K值从慢线D值的下方向上穿越慢线D值形成交叉，同是超快确认线J值从KD值的下方一次向上穿越KD线，即三线同时交叉向上发散时，即称之为KDJ金叉二者就形成了KDJ指标的金叉形态。这个形态说明股价短期内的上涨动能有增强趋势，是看涨买入信号。</p>
<blockquote>
<p>KDJ死叉</p>
</blockquote>
<p>​        K线和D线高位死叉。当KDJ指标中的K线自上向下跌破D线时，二者就形成了死叉形态。这样的形态如果出现在50上方的高位，就被称为高位死叉。K线和D线的死叉形态说明市场上的多方力量越来越弱，空方力量逐渐增强，这是看跌卖出信号。若KDJ三线的死叉属于K值大于90，D值大于80，J值大于100，三线在超买区形成的死叉时，股价短期下跌的概率较高</p>
<blockquote>
<p>D线进入超买区间</p>
</blockquote>
<p>​            当D线突破80时，就是行情进入超买区间的信号。这个信号说明市场上的多方力量已经达到极度强势的状态，不过这种强势状态可能难以持续。一旦多方力量开始衰退，空方力量增强，股价就将见顶下跌，因此这是看跌卖出信号。</p>
<blockquote>
<p>J线进入超买区间</p>
</blockquote>
<p>​            当KDJ指标中的J线突破100时，就是进入了超买区间。这样的形态说明股价在短期内快速上涨，市场上的多方力量已经强势到极致。一旦多方力量盛极而衰，空方力量复苏，股价即将见顶下跌。</p>
<h1 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h1><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141142436">https://zhuanlan.zhihu.com/p/141142436</a></p>
<p>RSI(6,12,24) 范围 [0,100]</p>
<ul>
<li>80-100 极强 卖出</li>
<li>50-80 强 买入</li>
<li>20-50 弱 观望</li>
<li>0-20 极弱 买入</li>
</ul>
<blockquote>
<p>常见买入点</p>
</blockquote>
<p>RSI6向上突破RSI12时，形成<strong>金叉</strong>，是买入点</p>
<p>当RSI6在20以下，同时出现拐点，突破20时，是买入点</p>
<p>趋势线，在RSI上做出一条趋势线，当向上突破趋势线，是买入信号</p>
<blockquote>
<p>常见卖出点</p>
</blockquote>
<p>RSI6向下突破RSI12时，形成<strong>死叉</strong>，是卖出点</p>
<p>当RSI6在80以上，同时出现拐点，跌破80时，是卖出点</p>
<p>双肩顶。在高位，且形成双肩的形态，是卖出信号</p>
<p><strong>RSI注意事项</strong><br>RSI 6指标是一个短线技术指标，适合分析较短周期内股价的走势。在反应市场上短线的背离现象方面，RSI 6线会比较灵敏；而在反应市场上的超买超卖状况方面，KDJ指标要更加灵敏。对于一些热点股票，RSI 6波动较大，买入卖出的参考性不大</p>
<h1 id="OBV"><a href="#OBV" class="headerlink" title="OBV"></a>OBV</h1><p>能量潮指标 参考：<a target="_blank" rel="noopener" href="https://www.sohu.com/a/140938204_110955">https://www.sohu.com/a/140938204_110955</a></p>
<p>一条线为MAOBV线：MAOBV线其实就是指OBV指标的30天的平均量的线</p>
<p>一条线为OBV线：是由近体的收盘价减去上个交易日的收盘价形成的，如果这个差是正数的话，就取正量值，如果是负数就取负量值，如果是0的话，就代表OBV线没有波动</p>
<p>如果MAOBV线向上弯曲，并且OBV线是正值并且上破了MAOBV线的话，就说明目前股价成交量在扩增，并且股价会上涨。相反，股价下跌的时候，OBV线会渐渐的变低，最后下破MVOBV线，呈空头趋势。</p>
<p>1、如果OBV指标波动情况为N字形，持续上攻的时候，投资人应该继续持股。如果OBV指标呈小N上攻，并且在某段时间内迅速的上涨，一般都意味着行情会出现反转。</p>
<p>2、OBV线长时间内横向运动，但是某天却快速上涨，并且突破MAOBV线，这种情况一般就代表着大行情的到来。</p>
<h1 id="WR"><a href="#WR" class="headerlink" title="WR"></a>WR</h1><p>威廉指标</p>
<p>WR指标会在0-100区间波动，其中0-20这一区间是超买区。而20这一线为超买线;80-100这一区间是超卖区，而80线为超卖线;50线为多空平衡线。</p>
<p>1.低于20，超买，即将见顶，应及时卖出<br>2.高于80，超卖，即将见底，应伺机买进</p>
<h1 id="CCI"><a href="#CCI" class="headerlink" title="CCI"></a>CCI</h1><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sjpljr/article/details/70169333">https://blog.csdn.net/sjpljr/article/details/70169333</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80812911">https://zhuanlan.zhihu.com/p/80812911</a></p>
<p>CCI指标就是专门针对极端情况设计的，也就是说，在一般常态行情下，CCI指标不会发生作用，当CCI扫描到异常股价波动时，立求速战速决，胜负瞬间立即分晓，赌输了也必须立刻了结。</p>
<p>CCI指标上穿-100时可买入，反之跌破+100时卖出</p>
<p>1、做中、长线的话：首先看周线，然后结合MACD、BOLL、OBV，结合30天、60天、120天均线比较好；</p>
<p>2、如果是中、短线：则以日线为主，同时可以看30分钟线，再结合RSI、KDJ 、WR、结合5天、10天、30天均线，则灵活；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/03/02/%E7%BF%BB%E8%AF%91/%E7%9F%A5%E5%90%8D%E8%8B%B1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/%E7%BF%BB%E8%AF%91/%E7%9F%A5%E5%90%8D%E8%8B%B1%E6%96%87/" class="post-title-link" itemprop="url">知名英文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 22:25:44" itemprop="dateCreated datePublished" datetime="2022-03-02T22:25:44+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 23:17:37" itemprop="dateModified" datetime="2022-03-23T23:17:37+08:00">2022-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>dormant</code>:休眠的；暂时不活动的；（线程休眠）</p>
<p><code>erroneous use</code>:错误使用</p>
<p><code>in such circumstances</code>:在这种情形下</p>
<p><code>chaotic</code>: 混乱的</p>
<p><code>incurring</code>:招致</p>
<p><code>derived from</code>:来源于</p>
<p><code>retrieval</code>: n.检索</p>
<p><code>obey</code>: v.遵从</p>
<p><code>entail</code>: v.涉及; 需要; 牵涉; 使必要;</p>
<p><code>aggregate operation</code>: 聚合操作</p>
<p><code>Bear in mind that</code>: 记住</p>
<p><code>adequate</code>: 足够的 适当的 充足 充分的</p>
<p><code>collision</code>: n.碰撞 冲突</p>
<p><code>modulo</code>: 以…为模</p>
<p><code>density</code>: 密度 稠密度</p>
<p><code>compatibility</code>: 兼容性</p>
<p><code>ameliorate</code>: 改善</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ztt0tian.github.io/2022/02/25/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zhaotian">
      <meta itemprop="description" content="可能不够详细，但会尽量实用">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不知名TT">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/%E6%BA%90%E7%A0%81/jdk%E6%BA%90%E7%A0%81/HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-25 23:30:26 / 修改时间：23:33:10" itemprop="dateCreated datePublished" datetime="2022-02-25T23:30:26+08:00">2022-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h1><p>基于哈希表实现，支持key为null，value为null，与HashTable类似（区别就是hashMap是unsynchronized的和支持null值，不保证元素的顺序及其顺序固定。如果假定hash函数能够将所有元素均匀地分布在所有bucket中，那么<code>get</code>和<code>put</code>基础操作的时间消耗将为常数项时间O(1),性能最大化。在该集合上的迭代性能与其容量和键值对的数量成正比，因此若要保证较高的迭代性能，初始化时不要将初始容量设置的过大（同理也不要将负载因子设置的太小）。HashMap的性能主要受两个属性影响：</p>
<p><code>initial capacity</code> 初始容量(创建哈希表时的bucket数量)</p>
<p><code>load factor</code> 负载因子(度量哈希表在下一次扩容前能装多满)</p>
<p>当在哈希表中的键值对数量超过了 当前容量和负载因子之积，当前哈希表重新进行哈希映射（即内部已存数据会被重构）</p>
<p>通常 负载因子默认为0.75，是时间和空间的一个较好权衡；太高确实可以减少空间开销但是会增加检索消耗（影响HashMap的大部分操作如<code>get</code>和<code>put</code>）；在设置HashMap的初始容量时应当考虑预期的键值对数量和负载因子，这样可以最小化扩容次数，即减少rehash次数。如果初始容量大于最大键值对除以负载因子，则不会发送<code>rehash</code>（因为不会发生扩容）</p>
<p>当需要存储较多键值对时，初始时就设置充足的容量比起让hashMap自动扩容要好得多。注意当使用相同<code>hashCode()</code>的key会降低哈希表的性能，为了改善这一影响，建议key实现<code>Comparable</code>接口（todo 具体原因待查）。</p>
<p>其实现不是同步的，当多个线程对其进行结构性修改时 必须在外部进行同步处理：如<code>Collections.synchronizedMap</code>,最后在创建时就进行该操作</p>
<p><code>Map m = Collections.synchronizedMap(new HashMap(...));</code></p>
<p>其迭代器是<strong>快速失败</strong>的：当迭代器创建之后，在该map上的任何结构性修改处理迭代器自身的<code>remove</code>方法都会抛出<code>ConcurrentModificationException</code>;当存在非同步的并发修改时，不能保证迭代器的快速失败行为， 快速失败迭代器 是尽最大努力抛出<code>ConcurrentModificationException</code>异常。 迭代器的快速失败行为应该只被用于检测bug</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量为16 必须是2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 最大容量限制 2^30  在java中1&lt;&lt;31已经是负数了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 树化链表(转化为红黑树)的节点数阈值（一个bucket内的节点数）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 树退化的节点数阈值（一个bucket内的节点数）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 发升树化的最小节点总数（否则应该是扩容减少冲突而不是树化）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>bin可以理解为表的槽</p>
<h2 id="基础bin节点内部类（普通节点）"><a href="#基础bin节点内部类（普通节点）" class="headerlink" title="基础bin节点内部类（普通节点）"></a>基础bin节点内部类（普通节点）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="树型bin节点内部类（红黑树待研究）"><a href="#树型bin节点内部类（红黑树待研究）" class="headerlink" title="树型bin节点内部类（红黑树待研究）"></a>树型bin节点内部类（红黑树待研究）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line">        boolean red;</span><br><span class="line">        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns root of tree containing this node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) &#123;</span><br><span class="line">                if ((p &#x3D; r.parent) &#x3D;&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                r &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Ensures that the given root is the first node of its bin.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class="line">            int n;</span><br><span class="line">            if (root !&#x3D; null &amp;&amp; tab !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0) &#123;</span><br><span class="line">                int index &#x3D; (n - 1) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                if (root !&#x3D; first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] &#x3D; root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp &#x3D; root.prev;</span><br><span class="line">                    if ((rn &#x3D; root.next) !&#x3D; null)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev &#x3D; rp;</span><br><span class="line">                    if (rp !&#x3D; null)</span><br><span class="line">                        rp.next &#x3D; rn;</span><br><span class="line">                    if (first !&#x3D; null)</span><br><span class="line">                        first.prev &#x3D; root;</span><br><span class="line">                    root.next &#x3D; first;</span><br><span class="line">                    root.prev &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                assert checkInvariants(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Finds the node starting at root p with the given hash and key.</span><br><span class="line">         * The kc argument caches comparableClassFor(key) upon first use</span><br><span class="line">         * comparing keys.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; this;</span><br><span class="line">            do &#123;</span><br><span class="line">                int ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl &#x3D; p.left, pr &#x3D; p.right, q;</span><br><span class="line">                if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    p &#x3D; pl;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    p &#x3D; pr;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if (pl &#x3D;&#x3D; null)</span><br><span class="line">                    p &#x3D; pr;</span><br><span class="line">                else if (pr &#x3D;&#x3D; null)</span><br><span class="line">                    p &#x3D; pl;</span><br><span class="line">                else if ((kc !&#x3D; null ||</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) !&#x3D; null) &amp;&amp;</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) !&#x3D; 0)</span><br><span class="line">                    p &#x3D; (dir &lt; 0) ? pl : pr;</span><br><span class="line">                else if ((q &#x3D; pr.find(h, k, kc)) !&#x3D; null)</span><br><span class="line">                    return q;</span><br><span class="line">                else</span><br><span class="line">                    p &#x3D; pl;</span><br><span class="line">            &#125; while (p !&#x3D; null);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Calls find for root node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">            return ((parent !&#x3D; null) ? root() : this).find(h, k, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Tie-breaking utility for ordering insertions when equal</span><br><span class="line">         * hashCodes and non-comparable. We don&#39;t require a total</span><br><span class="line">         * order, just a consistent insertion rule to maintain</span><br><span class="line">         * equivalence across rebalancings. Tie-breaking further than</span><br><span class="line">         * necessary simplifies testing a bit.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static int tieBreakOrder(Object a, Object b) &#123;</span><br><span class="line">            int d;</span><br><span class="line">            if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null ||</span><br><span class="line">                (d &#x3D; a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) &#x3D;&#x3D; 0)</span><br><span class="line">                d &#x3D; (System.identityHashCode(a) &lt;&#x3D; System.identityHashCode(b) ?</span><br><span class="line">                     -1 : 1);</span><br><span class="line">            return d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Forms tree of the nodes linked from this node.</span><br><span class="line">         * @return root of tree</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root &#x3D; null;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; x &#x3D; this, next; x !&#x3D; null; x &#x3D; next) &#123;</span><br><span class="line">                next &#x3D; (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left &#x3D; x.right &#x3D; null;</span><br><span class="line">                if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    x.parent &#x3D; null;</span><br><span class="line">                    x.red &#x3D; false;</span><br><span class="line">                    root &#x3D; x;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    K k &#x3D; x.key;</span><br><span class="line">                    int h &#x3D; x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">                    for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                        int dir, ph;</span><br><span class="line">                        K pk &#x3D; p.key;</span><br><span class="line">                        if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                            dir &#x3D; -1;</span><br><span class="line">                        else if (ph &lt; h)</span><br><span class="line">                            dir &#x3D; 1;</span><br><span class="line">                        else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                                  (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                                 (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0)</span><br><span class="line">                            dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                        if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            x.parent &#x3D; xp;</span><br><span class="line">                            if (dir &lt;&#x3D; 0)</span><br><span class="line">                                xp.left &#x3D; x;</span><br><span class="line">                            else</span><br><span class="line">                                xp.right &#x3D; x;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns a list of non-TreeNodes replacing those linked from</span><br><span class="line">         * this node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;</span><br><span class="line">            Node&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">            for (Node&lt;K,V&gt; q &#x3D; this; q !&#x3D; null; q &#x3D; q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p &#x3D; map.replacementNode(q, null);</span><br><span class="line">                if (tl &#x3D;&#x3D; null)</span><br><span class="line">                    hd &#x3D; p;</span><br><span class="line">                else</span><br><span class="line">                    tl.next &#x3D; p;</span><br><span class="line">                tl &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            return hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Tree version of putVal.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                       int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            TreeNode&lt;K,V&gt; root &#x3D; (parent !&#x3D; null) ? root() : this;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.find(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.find(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn &#x3D; xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x &#x3D; map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    xp.next &#x3D; x;</span><br><span class="line">                    x.parent &#x3D; x.prev &#x3D; xp;</span><br><span class="line">                    if (xpn !&#x3D; null)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev &#x3D; x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Removes the given node, that must be present before this call.</span><br><span class="line">         * This is messier than typical red-black deletion code because we</span><br><span class="line">         * cannot swap the contents of an interior node with a leaf</span><br><span class="line">         * successor that is pinned by &quot;next&quot; pointers that are accessible</span><br><span class="line">         * independently during traversal. So instead we swap the tree</span><br><span class="line">         * linkages. If the current tree appears to have too few nodes,</span><br><span class="line">         * the bin is converted back to a plain bin. (The test triggers</span><br><span class="line">         * somewhere between 2 and 6 nodes, depending on tree structure).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                  boolean movable) &#123;</span><br><span class="line">            int n;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                return;</span><br><span class="line">            int index &#x3D; (n - 1) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index], root &#x3D; first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ &#x3D; (TreeNode&lt;K,V&gt;)next, pred &#x3D; prev;</span><br><span class="line">            if (pred &#x3D;&#x3D; null)</span><br><span class="line">                tab[index] &#x3D; first &#x3D; succ;</span><br><span class="line">            else</span><br><span class="line">                pred.next &#x3D; succ;</span><br><span class="line">            if (succ !&#x3D; null)</span><br><span class="line">                succ.prev &#x3D; pred;</span><br><span class="line">            if (first &#x3D;&#x3D; null)</span><br><span class="line">                return;</span><br><span class="line">            if (root.parent !&#x3D; null)</span><br><span class="line">                root &#x3D; root.root();</span><br><span class="line">            if (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||</span><br><span class="line">                (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; this, pl &#x3D; left, pr &#x3D; right, replacement;</span><br><span class="line">            if (pl !&#x3D; null &amp;&amp; pr !&#x3D; null) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s &#x3D; pr, sl;</span><br><span class="line">                while ((sl &#x3D; s.left) !&#x3D; null) &#x2F;&#x2F; find successor</span><br><span class="line">                    s &#x3D; sl;</span><br><span class="line">                boolean c &#x3D; s.red; s.red &#x3D; p.red; p.red &#x3D; c; &#x2F;&#x2F; swap colors</span><br><span class="line">                TreeNode&lt;K,V&gt; sr &#x3D; s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp &#x3D; p.parent;</span><br><span class="line">                if (s &#x3D;&#x3D; pr) &#123; &#x2F;&#x2F; p was s&#39;s direct parent</span><br><span class="line">                    p.parent &#x3D; s;</span><br><span class="line">                    s.right &#x3D; p;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp &#x3D; s.parent;</span><br><span class="line">                    if ((p.parent &#x3D; sp) !&#x3D; null) &#123;</span><br><span class="line">                        if (s &#x3D;&#x3D; sp.left)</span><br><span class="line">                            sp.left &#x3D; p;</span><br><span class="line">                        else</span><br><span class="line">                            sp.right &#x3D; p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ((s.right &#x3D; pr) !&#x3D; null)</span><br><span class="line">                        pr.parent &#x3D; s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left &#x3D; null;</span><br><span class="line">                if ((p.right &#x3D; sr) !&#x3D; null)</span><br><span class="line">                    sr.parent &#x3D; p;</span><br><span class="line">                if ((s.left &#x3D; pl) !&#x3D; null)</span><br><span class="line">                    pl.parent &#x3D; s;</span><br><span class="line">                if ((s.parent &#x3D; pp) &#x3D;&#x3D; null)</span><br><span class="line">                    root &#x3D; s;</span><br><span class="line">                else if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                    pp.left &#x3D; s;</span><br><span class="line">                else</span><br><span class="line">                    pp.right &#x3D; s;</span><br><span class="line">                if (sr !&#x3D; null)</span><br><span class="line">                    replacement &#x3D; sr;</span><br><span class="line">                else</span><br><span class="line">                    replacement &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (pl !&#x3D; null)</span><br><span class="line">                replacement &#x3D; pl;</span><br><span class="line">            else if (pr !&#x3D; null)</span><br><span class="line">                replacement &#x3D; pr;</span><br><span class="line">            else</span><br><span class="line">                replacement &#x3D; p;</span><br><span class="line">            if (replacement !&#x3D; p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp &#x3D; replacement.parent &#x3D; p.parent;</span><br><span class="line">                if (pp &#x3D;&#x3D; null)</span><br><span class="line">                    root &#x3D; replacement;</span><br><span class="line">                else if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                    pp.left &#x3D; replacement;</span><br><span class="line">                else</span><br><span class="line">                    pp.right &#x3D; replacement;</span><br><span class="line">                p.left &#x3D; p.right &#x3D; p.parent &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r &#x3D; p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            if (replacement &#x3D;&#x3D; p) &#123;  &#x2F;&#x2F; detach</span><br><span class="line">                TreeNode&lt;K,V&gt; pp &#x3D; p.parent;</span><br><span class="line">                p.parent &#x3D; null;</span><br><span class="line">                if (pp !&#x3D; null) &#123;</span><br><span class="line">                    if (p &#x3D;&#x3D; pp.left)</span><br><span class="line">                        pp.left &#x3D; null;</span><br><span class="line">                    else if (p &#x3D;&#x3D; pp.right)</span><br><span class="line">                        pp.right &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Splits nodes in a tree bin into lower and upper tree bins,</span><br><span class="line">         * or untreeifies if now too small. Called only from resize;</span><br><span class="line">         * see above discussion about split bits and indices.</span><br><span class="line">         *</span><br><span class="line">         * @param map the map</span><br><span class="line">         * @param tab the table for recording bin heads</span><br><span class="line">         * @param index the index of the table being split</span><br><span class="line">         * @param bit the bit of hash to split on</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b &#x3D; this;</span><br><span class="line">            &#x2F;&#x2F; Relink into lo and hi lists, preserving order</span><br><span class="line">            TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">            int lc &#x3D; 0, hc &#x3D; 0;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;</span><br><span class="line">                next &#x3D; (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next &#x3D; null;</span><br><span class="line">                if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)</span><br><span class="line">                        loHead &#x3D; e;</span><br><span class="line">                    else</span><br><span class="line">                        loTail.next &#x3D; e;</span><br><span class="line">                    loTail &#x3D; e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)</span><br><span class="line">                        hiHead &#x3D; e;</span><br><span class="line">                    else</span><br><span class="line">                        hiTail.next &#x3D; e;</span><br><span class="line">                    hiTail &#x3D; e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (loHead !&#x3D; null) &#123;</span><br><span class="line">                if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] &#x3D; loHead.untreeify(map);</span><br><span class="line">                else &#123;</span><br><span class="line">                    tab[index] &#x3D; loHead;</span><br><span class="line">                    if (hiHead !&#x3D; null) &#x2F;&#x2F; (else is already treeified)</span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (hiHead !&#x3D; null) &#123;</span><br><span class="line">                if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] &#x3D; hiHead.untreeify(map);</span><br><span class="line">                else &#123;</span><br><span class="line">                    tab[index + bit] &#x3D; hiHead;</span><br><span class="line">                    if (loHead !&#x3D; null)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* ------------------------------------------------------------ *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Red-black tree methods, all adapted from CLR</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                              TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            if (p !&#x3D; null &amp;&amp; (r &#x3D; p.right) !&#x3D; null) &#123;</span><br><span class="line">                if ((rl &#x3D; p.right &#x3D; r.left) !&#x3D; null)</span><br><span class="line">                    rl.parent &#x3D; p;</span><br><span class="line">                if ((pp &#x3D; r.parent &#x3D; p.parent) &#x3D;&#x3D; null)</span><br><span class="line">                    (root &#x3D; r).red &#x3D; false;</span><br><span class="line">                else if (pp.left &#x3D;&#x3D; p)</span><br><span class="line">                    pp.left &#x3D; r;</span><br><span class="line">                else</span><br><span class="line">                    pp.right &#x3D; r;</span><br><span class="line">                r.left &#x3D; p;</span><br><span class="line">                p.parent &#x3D; r;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            if (p !&#x3D; null &amp;&amp; (l &#x3D; p.left) !&#x3D; null) &#123;</span><br><span class="line">                if ((lr &#x3D; p.left &#x3D; l.right) !&#x3D; null)</span><br><span class="line">                    lr.parent &#x3D; p;</span><br><span class="line">                if ((pp &#x3D; l.parent &#x3D; p.parent) &#x3D;&#x3D; null)</span><br><span class="line">                    (root &#x3D; l).red &#x3D; false;</span><br><span class="line">                else if (pp.right &#x3D;&#x3D; p)</span><br><span class="line">                    pp.right &#x3D; l;</span><br><span class="line">                else</span><br><span class="line">                    pp.left &#x3D; l;</span><br><span class="line">                l.right &#x3D; p;</span><br><span class="line">                p.parent &#x3D; l;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                    TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">            x.red &#x3D; true;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    x.red &#x3D; false;</span><br><span class="line">                    return x;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!xp.red || (xpp &#x3D; xp.parent) &#x3D;&#x3D; null)</span><br><span class="line">                    return root;</span><br><span class="line">                if (xp &#x3D;&#x3D; (xppl &#x3D; xpp.left)) &#123;</span><br><span class="line">                    if ((xppr &#x3D; xpp.right) !&#x3D; null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red &#x3D; false;</span><br><span class="line">                        xp.red &#x3D; false;</span><br><span class="line">                        xpp.red &#x3D; true;</span><br><span class="line">                        x &#x3D; xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (x &#x3D;&#x3D; xp.right) &#123;</span><br><span class="line">                            root &#x3D; rotateLeft(root, x &#x3D; xp);</span><br><span class="line">                            xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp !&#x3D; null) &#123;</span><br><span class="line">                            xp.red &#x3D; false;</span><br><span class="line">                            if (xpp !&#x3D; null) &#123;</span><br><span class="line">                                xpp.red &#x3D; true;</span><br><span class="line">                                root &#x3D; rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (xppl !&#x3D; null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red &#x3D; false;</span><br><span class="line">                        xp.red &#x3D; false;</span><br><span class="line">                        xpp.red &#x3D; true;</span><br><span class="line">                        x &#x3D; xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (x &#x3D;&#x3D; xp.left) &#123;</span><br><span class="line">                            root &#x3D; rotateRight(root, x &#x3D; xp);</span><br><span class="line">                            xpp &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp !&#x3D; null) &#123;</span><br><span class="line">                            xp.red &#x3D; false;</span><br><span class="line">                            if (xpp !&#x3D; null) &#123;</span><br><span class="line">                                xpp.red &#x3D; true;</span><br><span class="line">                                root &#x3D; rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                   TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">                if (x &#x3D;&#x3D; null || x &#x3D;&#x3D; root)</span><br><span class="line">                    return root;</span><br><span class="line">                else if ((xp &#x3D; x.parent) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    x.red &#x3D; false;</span><br><span class="line">                    return x;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (x.red) &#123;</span><br><span class="line">                    x.red &#x3D; false;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((xpl &#x3D; xp.left) &#x3D;&#x3D; x) &#123;</span><br><span class="line">                    if ((xpr &#x3D; xp.right) !&#x3D; null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red &#x3D; false;</span><br><span class="line">                        xp.red &#x3D; true;</span><br><span class="line">                        root &#x3D; rotateLeft(root, xp);</span><br><span class="line">                        xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpr &#x3D;&#x3D; null)</span><br><span class="line">                        x &#x3D; xp;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl &#x3D; xpr.left, sr &#x3D; xpr.right;</span><br><span class="line">                        if ((sr &#x3D;&#x3D; null || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl &#x3D;&#x3D; null || !sl.red)) &#123;</span><br><span class="line">                            xpr.red &#x3D; true;</span><br><span class="line">                            x &#x3D; xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (sr &#x3D;&#x3D; null || !sr.red) &#123;</span><br><span class="line">                                if (sl !&#x3D; null)</span><br><span class="line">                                    sl.red &#x3D; false;</span><br><span class="line">                                xpr.red &#x3D; true;</span><br><span class="line">                                root &#x3D; rotateRight(root, xpr);</span><br><span class="line">                                xpr &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?</span><br><span class="line">                                    null : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xpr !&#x3D; null) &#123;</span><br><span class="line">                                xpr.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;</span><br><span class="line">                                if ((sr &#x3D; xpr.right) !&#x3D; null)</span><br><span class="line">                                    sr.red &#x3D; false;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xp !&#x3D; null) &#123;</span><br><span class="line">                                xp.red &#x3D; false;</span><br><span class="line">                                root &#x3D; rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x &#x3D; root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; &#x2F;&#x2F; symmetric</span><br><span class="line">                    if (xpl !&#x3D; null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red &#x3D; false;</span><br><span class="line">                        xp.red &#x3D; true;</span><br><span class="line">                        root &#x3D; rotateRight(root, xp);</span><br><span class="line">                        xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ? null : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpl &#x3D;&#x3D; null)</span><br><span class="line">                        x &#x3D; xp;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl &#x3D; xpl.left, sr &#x3D; xpl.right;</span><br><span class="line">                        if ((sl &#x3D;&#x3D; null || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr &#x3D;&#x3D; null || !sr.red)) &#123;</span><br><span class="line">                            xpl.red &#x3D; true;</span><br><span class="line">                            x &#x3D; xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (sl &#x3D;&#x3D; null || !sl.red) &#123;</span><br><span class="line">                                if (sr !&#x3D; null)</span><br><span class="line">                                    sr.red &#x3D; false;</span><br><span class="line">                                xpl.red &#x3D; true;</span><br><span class="line">                                root &#x3D; rotateLeft(root, xpl);</span><br><span class="line">                                xpl &#x3D; (xp &#x3D; x.parent) &#x3D;&#x3D; null ?</span><br><span class="line">                                    null : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xpl !&#x3D; null) &#123;</span><br><span class="line">                                xpl.red &#x3D; (xp &#x3D;&#x3D; null) ? false : xp.red;</span><br><span class="line">                                if ((sl &#x3D; xpl.left) !&#x3D; null)</span><br><span class="line">                                    sl.red &#x3D; false;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xp !&#x3D; null) &#123;</span><br><span class="line">                                xp.red &#x3D; false;</span><br><span class="line">                                root &#x3D; rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x &#x3D; root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Recursive invariant check</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp &#x3D; t.parent, tl &#x3D; t.left, tr &#x3D; t.right,</span><br><span class="line">                tb &#x3D; t.prev, tn &#x3D; (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            if (tb !&#x3D; null &amp;&amp; tb.next !&#x3D; t)</span><br><span class="line">                return false;</span><br><span class="line">            if (tn !&#x3D; null &amp;&amp; tn.prev !&#x3D; t)</span><br><span class="line">                return false;</span><br><span class="line">            if (tp !&#x3D; null &amp;&amp; t !&#x3D; tp.left &amp;&amp; t !&#x3D; tp.right)</span><br><span class="line">                return false;</span><br><span class="line">            if (tl !&#x3D; null &amp;&amp; (tl.parent !&#x3D; t || tl.hash &gt; t.hash))</span><br><span class="line">                return false;</span><br><span class="line">            if (tr !&#x3D; null &amp;&amp; (tr.parent !&#x3D; t || tr.hash &lt; t.hash))</span><br><span class="line">                return false;</span><br><span class="line">            if (t.red &amp;&amp; tl !&#x3D; null &amp;&amp; tl.red &amp;&amp; tr !&#x3D; null &amp;&amp; tr.red)</span><br><span class="line">                return false;</span><br><span class="line">            if (tl !&#x3D; null &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                return false;</span><br><span class="line">            if (tr !&#x3D; null &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="KeySet-键的自定义Set集合"><a href="#KeySet-键的自定义Set集合" class="headerlink" title="KeySet(键的自定义Set集合)"></a>KeySet(键的自定义Set集合)</h2><p>主要用于keySet()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="comment">// 内部类调用外部类的方法，这里HashMap.this是为了与AbstractCollection中的clear实现区分</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="comment">// 这个迭代器很关键 将其与map的元素关联起来了</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="comment">// 内部类调用外部类的方法 可以直接调</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割迭代器 为了并行遍历元素而设计的一个迭代器(具体待深入研究)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据传入的行为进行迭代操作 会检验modCount</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Values-值的自定义集合"><a href="#Values-值的自定义集合" class="headerlink" title="Values(值的自定义集合)"></a>Values(值的自定义集合)</h2><p>类似于KeySet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="KeyIterator-键的迭代器定义"><a href="#KeyIterator-键的迭代器定义" class="headerlink" title="KeyIterator(键的迭代器定义)"></a>KeyIterator(键的迭代器定义)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ValueIterator-值的迭代器定义"><a href="#ValueIterator-值的迭代器定义" class="headerlink" title="ValueIterator(值的迭代器定义)"></a>ValueIterator(值的迭代器定义)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="EntryIterator-键值对的迭代器定义"><a href="#EntryIterator-键值对的迭代器定义" class="headerlink" title="EntryIterator(键值对的迭代器定义)"></a>EntryIterator(键值对的迭代器定义)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><blockquote>
<p>计算哈希值</p>
</blockquote>
<p>赋值给h，然后在h的基础上向右位移16位得到h16,最后通过异或计算h与h16的结果就是最终key的hash值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断是否有实现Comparable接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;  <span class="comment">// 判断是否实现了Comparable接口</span></span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) </span><br><span class="line">                <span class="keyword">return</span> c;   <span class="comment">// 如果是String类型，直接返回String.class</span></span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;  <span class="comment">// 判断是否有直接实现的接口</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;   <span class="comment">// 遍历直接实现的接口</span></span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;   <span class="comment">// 该接口实现了泛型</span></span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() == <span class="comment">// 获取接口不带参数部分的类型对象</span></span><br><span class="line">                         Comparable.class) &amp;&amp;   //  该类型是Comparable</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;    <span class="comment">// 获取泛型参数数组</span></span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c)   <span class="comment">// 只有一个泛型参数，且该实现类型是该类型本身</span></span><br><span class="line">                        <span class="keyword">return</span> c;   <span class="comment">// 返回该类型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解读参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qpzkobe/article/details/79533237">https://blog.csdn.net/qpzkobe/article/details/79533237</a></p>
<blockquote>
<p>比较</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果x所属的类是kc，返回k.compareTo(x)的比较结果</span></span><br><span class="line"><span class="comment">* 如果x为空，或者其所属的类不是kc，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>容量标准化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传进来的参数n转变为2的n次方的数值</span></span><br><span class="line"><span class="comment"> * 返回大于输入参数且最近的2的整数次幂的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">// 该算法让最高位的1后面的位全变为1</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>关于 &lt;&lt; 、&gt;&gt;、&gt;&gt;&gt;的解释：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chuijingjing/p/9405598.html">https://www.cnblogs.com/chuijingjing/p/9405598.html</a></p>
<p>该函数的解读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/loading4/p/6239441.html">https://www.cnblogs.com/loading4/p/6239441.html</a></p>
<h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 指定初始容量和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 仅指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 指定map构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><p>（包）表示default方法权限</p>
<h4 id="putMapEntries-包"><a href="#putMapEntries-包" class="headerlink" title="putMapEntries(包)"></a>putMapEntries(包)</h4><p>详细解析参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/anlian523/article/details/103639094">https://blog.csdn.net/anlian523/article/details/103639094</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 为了后续的int转换向上取整</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放不下时 需要先进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="comment">// 逐个放入键值</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="getNode-包"><a href="#getNode-包" class="headerlink" title="getNode(包)"></a>getNode(包)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// 根据hash定位到bin槽</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查这个槽的第一个元素key是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是树型节点 表示这个槽的节点列表已经树化 通过当前树节点查找</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 否则就是普通的链表遍历查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>定位依据：<a target="_blank" rel="noopener" href="https://www.yht7.com/news/11148">hash &amp; ( n - 1 ) = hash % n</a>  简单就是被除数的二进制 高位直接消 低位保留</p>
<h4 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相同key重复put val值会被覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="putVal-包"><a href="#putVal-包" class="headerlink" title="putVal(包)"></a>putVal(包)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent 是否仅在不存在时才插入</span></span><br><span class="line"><span class="comment"> * evict 如果为false，表示表处于创建模式</span></span><br><span class="line"><span class="comment"> * 返回之前的值 不存在则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n---map的容量</span></span><br><span class="line">        <span class="comment">// i---对应槽的索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 初始化校验</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 对应槽为null 直接新建bin并插入</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在hash冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 以下就是去找要插入的那个bin</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 树型bin的插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 尾插法插入如果达到树化阈值则对链表进行树化</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 先插</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 根据hash树化对应槽上的节点列表 </span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已存在映射 则视情况替换</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 这是个空方法 在LinkedHashMap会重写 这里为啥调用一下 暂不明天</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是替换 则就是新增一个bin 发生结构性修改</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 也是空方法 在LinkedHashMap中才会用</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="resize-包"><a href="#resize-包" class="headerlink" title="resize(包)"></a>resize(包)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新规整表格 一般初始化时 或者 扩容（size翻倍） 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算得出合理的newCap newThr</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 是否已无法扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;<span class="comment">// 最大化实际可容纳元素个数 之后不会再扩容</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可以扩容（扩容后的size小于最大值大于等于默认值）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 以默认配置初始化容量和阈值</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="comment">// 新建newCap大的数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 原表中的键值对移到新表当中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">// 当前槽有节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 旧表槽点置空 方便gc</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 槽内只有一个节点情况下 直接转移到新表中的对应槽位</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// 槽中节点为树型bin时 调用针对树型节点的调整方法</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 转移原槽中的链表至新链表中</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 低位节点链 &amp; N （二进制100...） </span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 高位节点链</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 低位节点链 槽位不变</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高位节点链 槽位右偏移一个原表长度</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="treeifyBin-包"><a href="#treeifyBin-包" class="headerlink" title="treeifyBin(包)"></a>treeifyBin(包)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表槽树化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 达到树化的槽节点数阈值也不一定树化 还需要总容量不小于树化总容量阈值，此时选择扩容而非树化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 这里只是把链表中的节点封装成Tree型节点 还未进行树化</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 树化操作</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="putAll"><a href="#putAll" class="headerlink" title="putAll"></a>putAll</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露出来的批量put接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据key移除元素 一个简单调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="removeNode-包"><a href="#removeNode-包" class="headerlink" title="removeNode(包)"></a>removeNode(包)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除节点操作 返回删除的那个节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="comment">// 存在性校验</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 比对槽中第一个节点是不是要删除的那个节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 树型槽查找</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 单链表查找</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据入参条件最终判断要不要删</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">// 树型节点移除</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">// 移除的是非树型节点且为第一个节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">// 移除的是非树型节点且不是第一个节点 此时的p是指向要删除node的前一个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                <span class="comment">// 空方法 在LinkedHash有用</span></span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 置空槽中元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="comment">// 结构性修改次数只加1次</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找是否有指定值 只能直接遍历的 无法利用红黑树的查找优势 即使转换为红黑树 其原链表的next关系也没有动</span></span><br><span class="line"><span class="comment">// 但是若本身已经是红黑树其next如何维护（待进一步理解）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回key的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有个问题 这里的所有变量定义都没有涉及HashMap中的key封装成Set，那是怎么获取的HashMap中的key值 的？</p>
<p>是通过KeySet的重写迭代器实现关联的</p>
<p>keySet()方法返回一个内部引用，并指向一个内部类对象，该内部类重写了迭代器方法，当在增强for循环时才调用，并从外部类的table中取值。</p>
<p>Set.toString 也是通过迭代器遍历实现的，所以直接打印keySet()也是可以显示出所有键</p>
<h4 id="values"><a href="#values" class="headerlink" title="values"></a>values</h4><p>分析同keySet类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h4><p>分析同keySet类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回键值对j集合</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk8扩展方法"><a href="#jdk8扩展方法" class="headerlink" title="jdk8扩展方法"></a>jdk8扩展方法</h3><h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault"></a>getOrDefault</h4><p>取值，取不到返回给定的默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h4><p> map不存在对应key的映射，或者映射的value为null才进行put ，结果返回被替代的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-k-v"><a href="#remove-k-v" class="headerlink" title="remove(k,v)"></a>remove(k,v)</h4><p>根据key val移除元素 均匹配才进行删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="replace-k-v-ov"><a href="#replace-k-v-ov" class="headerlink" title="replace(k,v,ov)"></a>replace(k,v,ov)</h4><p>根据key找到元素，若值不相等则进行替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e; V v;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">           e.value = newValue;</span><br><span class="line">           <span class="comment">// 空方法 LinkedHashMap中有用</span></span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="replace-k-v"><a href="#replace-k-v" class="headerlink" title="replace(k,v)"></a>replace(k,v)</h4><p>根据key找到元素,直接替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

















<h1 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对 bin容器 Node数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 键值对的Set容器 Entry&lt;K,V&gt;set集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// map中键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 发生结构性修改次数 计数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 下次resize的数量阈值=capacity*加载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><blockquote>
<p>hashmap为什么规定容量是2的n次幂</p>
</blockquote>
<p>方便根据hash&amp;n-1定位所属槽</p>
<blockquote>
<p>hashmap中树化的阈值为什么是8</p>
</blockquote>
<p>理想情况下，在随机hashCodes下，节点频率遵循泊松分布，链表链表长度为8时，命中概率相对较低了，此时使用转化成红黑树，查询效率比较高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhaotian"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zhaotian</p>
  <div class="site-description" itemprop="description">可能不够详细，但会尽量实用</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/whutzhaotian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;whutzhaotian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1290507445@qq.com" title="E-Mail → mailto:1290507445@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhaotian</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
